{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FastQC Summary","text":"<p>CLI app that summarizes FastQC results.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#fastqc-data-summaries","title":"FastQC data summaries","text":""},{"location":"api/#fastqc_summary.summaries.summarize_read_count","title":"<code>summarize_read_count(basic_stats)</code>","text":"<p>Extract the total count of reads from basic statistics module.</p> Source code in <code>src/fastqc_summary/summaries.py</code> <pre><code>def summarize_read_count(basic_stats: Module) -&gt; dict[str, int]:\n    \"\"\"Extract the total count of reads from basic statistics module.\"\"\"\n\n    read_count = None\n    # extract read count from total sequences line\n    for line in basic_stats.data:\n        if line.startswith(\"Total Sequences\"):\n            read_count = line.split(\"\\t\")[1]\n            break\n\n    # basic stats module must contain read counts\n    if not read_count:\n        raise ValueError(\"Read count not found in 'Basic Statistics' module.\")\n\n    return {\"read_count\": int(read_count)}\n</code></pre>"},{"location":"api/#fastqc_summary.summaries.summarize_base_count","title":"<code>summarize_base_count(seq_len_dist)</code>","text":"<p>Compute the total count of bases from sequence length distribution module.</p> Source code in <code>src/fastqc_summary/summaries.py</code> <pre><code>def summarize_base_count(seq_len_dist: Module) -&gt; dict[str, int]:\n    \"\"\"Compute the total count of bases from sequence length distribution module.\"\"\"\n\n    base_count = 0\n\n    # compute total count of bases\n    # the total count of bases in a file of sequence reads can be computed from a frequency table of sequence lengths\n    # that is, base_count = &lt;length, count&gt;, where &lt;length, count&gt; is the dot product of the two n-vectors length and count,\n    # length_i is the number of bases in the ith element, and\n    # count_i is the count of reads with the corresponding length\n    for line in seq_len_dist.data:\n        length_i, count_i = line.split(\"\\t\")\n        # handle conversion of counts with trailing \".0\" or scientific notation to integer\n        count_i = int(Decimal(count_i))\n        base_count += int(length_i) * count_i\n\n    return {\"base_count\": base_count}\n</code></pre>"},{"location":"api/#inputoutput","title":"Input/Output","text":""},{"location":"api/#fastqc_summary.parser.parse_modules","title":"<code>parse_modules(zip_path)</code>","text":"<p>Read and parse modules from fastqc_data.txt file in a ZIP archive.</p> <p>Parameters:</p> Name Type Description Default <code>zip_path</code> <code>str</code> <p>Path to a ZIP archive file.</p> required <p>Yields:</p> Type Description <code>Module</code> <p>A representation of a module from fastqc_data.txt.</p> Source code in <code>src/fastqc_summary/parser.py</code> <pre><code>def parse_modules(zip_path: str) -&gt; Iterator[Module]:\n    \"\"\"Read and parse modules from fastqc_data.txt file in a ZIP archive.\n\n    Args:\n        zip_path: Path to a ZIP archive file.\n\n    Yields:\n        A representation of a module from fastqc_data.txt.\n    \"\"\"\n    with (\n        zipfile.ZipFile(zip_path, \"r\") as archive,\n        archive.open(find_fastqc_data_file(archive), \"r\") as fastqc_data_bytes,\n        io.TextIOWrapper(fastqc_data_bytes, encoding=\"utf-8\") as fastqc_data_text,\n    ):\n        # initialize with an empty Module\n        module = Module(name=\"\", status=\"\", columns=[], data = [])\n\n        for line in fastqc_data_text:\n            line = line.rstrip()\n\n            # yield current module if end of module reached and module isn't empty\n            if line.startswith(\"&gt;&gt;END_MODULE\") and module.name:\n                yield module\n\n            # start new module\n            elif line.startswith(\"&gt;&gt;\") and not line.endswith(\"END_MODULE\"):\n                module = Module(name=line.split(\"\\t\")[0][2:], status=line.split(\"\\t\")[1], columns=[], data = [])\n\n            # add module column names\n            elif line.startswith(\"#\") and module.name:\n                module.columns = line[1:].split(\"\\t\")\n\n            # add data rows to module\n            elif module.name:\n                module.data.append(line)\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#fastqc_summary.printerr.printerr","title":"<code>printerr(e, exit_status=1)</code>","text":"<p>Print error message and exit.</p> <p>Print an error message to stderr, and exit with the given exit status.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>str</code> <p>An error message.</p> required <code>exit_status</code> <code>int</code> <p>An exit status to return.</p> <code>1</code> Source code in <code>src/fastqc_summary/printerr.py</code> <pre><code>def printerr(e: str, exit_status: int = 1) -&gt; None:\n    \"\"\"Print error message and exit.\n\n    Print an error message to stderr, and exit with the given exit status.\n\n    Args:\n        e: An error message.\n        exit_status: An exit status to return.\n    \"\"\"\n    print(f\"Error: {e}\", file=sys.stderr)\n    sys.exit(exit_status)\n</code></pre>"}]}